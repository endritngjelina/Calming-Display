<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Waterfall Serenity Enhanced - Ultra Realistic</title>
    <style>
        :root {
            --color-white: rgba(255, 255, 255, 1);
            --color-black: rgba(0, 0, 0, 1);
            --color-cream-50: rgba(252, 252, 249, 1);
            --color-gray-300: rgba(167, 169, 169, 1);
            --color-slate-500: rgba(98, 108, 113, 1);
            --color-slate-900: rgba(19, 52, 59, 1);
            --color-teal-300: rgba(50, 184, 198, 1);
            --color-teal-500: rgba(33, 128, 141, 1);
            --color-teal-600: rgba(29, 116, 128, 1);
            --color-background: var(--color-slate-900);
            --color-surface: rgba(38, 40, 40, 1);
            --color-text: var(--color-cream-50);
            --color-text-secondary: var(--color-gray-300);
            --color-primary: var(--color-teal-300);
            --color-primary-hover: var(--color-teal-500);
            --color-border: rgba(167, 169, 169, 0.3);
            --color-focus-ring: rgba(50, 184, 198, 0.4);
            --font-family-base: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --font-size-sm: 12px;
            --font-size-base: 14px;
            --font-size-md: 16px;
            --font-size-lg: 18px;
            --font-weight-medium: 500;
            --font-weight-semibold: 600;
            --space-4: 4px;
            --space-8: 8px;
            --space-12: 12px;
            --space-16: 16px;
            --space-20: 20px;
            --space-24: 24px;
            --radius-sm: 6px;
            --radius-base: 8px;
            --duration-normal: 250ms;
            --ease-standard: cubic-bezier(0.16, 1, 0.3, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family-base);
            background: var(--color-background);
            color: var(--color-text);
            overflow: hidden;
            height: 100vh;
            width: 100%;
        }

        .container {
            display: flex;
            height: 100vh;
            width: 100%;
        }

        canvas {
            flex: 1;
            display: block;
            background: linear-gradient(180deg, 
                rgba(135, 206, 250, 0.4) 0%,
                rgba(100, 180, 200, 0.3) 50%,
                rgba(50, 120, 150, 0.2) 100%);
        }

        .control-panel {
            position: fixed;
            left: 0;
            top: 0;
            height: 100vh;
            width: 320px;
            background: rgba(19, 52, 59, 0.98);
            backdrop-filter: blur(10px);
            border-right: 1px solid var(--color-border);
            overflow-y: auto;
            z-index: 100;
            transform: translateX(0);
            transition: transform var(--duration-normal) var(--ease-standard);
            padding: var(--space-16);
        }

        .control-panel.collapsed {
            transform: translateX(-100%);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-24);
            padding-bottom: var(--space-16);
            border-bottom: 1px solid var(--color-border);
        }

        .panel-title {
            font-size: var(--font-size-lg);
            font-weight: var(--font-weight-semibold);
            color: var(--color-primary);
        }

        .toggle-btn {
            display: none;
            background: var(--color-primary);
            color: var(--color-slate-900);
            border: none;
            border-radius: var(--radius-base);
            padding: var(--space-8) var(--space-12);
            cursor: pointer;
            font-weight: var(--font-weight-medium);
            transition: all var(--duration-normal) var(--ease-standard);
            position: fixed;
            left: var(--space-16);
            top: var(--space-16);
            z-index: 101;
        }

        .toggle-btn:hover {
            background: var(--color-primary-hover);
            transform: scale(1.05);
        }

        @media (max-width: 1024px) {
            .control-panel {
                width: 280px;
            }
            .toggle-btn {
                display: block;
            }
        }

        @media (max-width: 768px) {
            .control-panel {
                width: 100%;
                height: auto;
                position: fixed;
                top: auto;
                bottom: 0;
                left: 0;
                right: 0;
                border-right: none;
                border-top: 1px solid var(--color-border);
                transform: translateY(100%);
                max-height: 70vh;
                padding: var(--space-16);
            }
            .control-panel.collapsed {
                transform: translateY(100%);
            }
            .control-panel.open {
                transform: translateY(0);
            }
            .toggle-btn {
                left: auto;
                right: var(--space-16);
                bottom: 100%;
            }
            canvas {
                width: 100%;
            }
        }

        .control-group {
            margin-bottom: var(--space-24);
        }

        .control-label {
            display: block;
            font-size: var(--font-size-sm);
            font-weight: var(--font-weight-medium);
            margin-bottom: var(--space-8);
            color: var(--color-text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-value {
            font-size: var(--font-size-base);
            color: var(--color-primary);
            font-weight: var(--font-weight-semibold);
            margin-bottom: var(--space-8);
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(50, 184, 198, 0.2);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--color-primary);
            cursor: pointer;
            transition: background var(--duration-normal);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--color-primary);
            cursor: pointer;
            border: none;
            transition: background var(--duration-normal);
        }

        input[type="range"]:hover::-webkit-slider-thumb,
        input[type="range"]:hover::-moz-range-thumb {
            background: var(--color-primary-hover);
        }

        select {
            width: 100%;
            padding: var(--space-8) var(--space-12);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-base);
            background: rgba(50, 184, 198, 0.1);
            color: var(--color-text);
            font-family: var(--font-family-base);
            font-size: var(--font-size-base);
            cursor: pointer;
            transition: all var(--duration-normal);
        }

        select:hover {
            background: rgba(50, 184, 198, 0.15);
            border-color: var(--color-primary);
        }

        select:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 3px var(--color-focus-ring);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: var(--space-8);
            padding: var(--space-8) 0;
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: var(--color-primary);
        }

        .checkbox-label {
            font-size: var(--font-size-base);
            color: var(--color-text);
            cursor: pointer;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-12);
        }

        .feature-item {
            display: flex;
            align-items: center;
            gap: var(--space-8);
        }
    </style>
</head>
<body>
    <div class="container">
        <button class="toggle-btn" onclick="togglePanel()">Toggle Controls</button>
        
        <div class="control-panel" id="controlPanel">
            <div class="panel-header">
                <h1 class="panel-title">ðŸŒŠ Scene Controls</h1>
            </div>

            <div class="control-group">
                <label class="control-label">Time of Day</label>
                <div class="control-value" id="timeDisplay">12:00</div>
                <input type="range" id="timeSlider" min="0" max="24" value="12" step="0.5">
            </div>

            <div class="control-group">
                <label class="control-label">Water Intensity</label>
                <div class="control-value" id="intensityDisplay">50%</div>
                <input type="range" id="intensitySlider" min="0" max="100" value="50">
            </div>

            <div class="control-group">
                <label class="control-label">Mist Amount</label>
                <div class="control-value" id="mistDisplay">70%</div>
                <input type="range" id="mistSlider" min="0" max="100" value="70">
            </div>

            <div class="control-group">
                <label class="control-label">Animation Speed</label>
                <div class="control-value" id="speedDisplay">1.0x</div>
                <input type="range" id="speedSlider" min="0.1" max="2" value="1" step="0.1">
            </div>

            <div class="control-group">
                <label class="control-label">Weather</label>
                <select id="weatherSelect">
                    <option value="clear">Clear</option>
                    <option value="rain">Rain</option>
                    <option value="storm">Storm</option>
                </select>
            </div>

            <div class="control-group">
                <label class="control-label">Scene Features</label>
                <div class="feature-grid">
                    <div class="feature-item">
                        <input type="checkbox" id="rocksCheck" checked>
                        <label class="checkbox-label" for="rocksCheck">Rocks</label>
                    </div>
                    <div class="feature-item">
                        <input type="checkbox" id="birdsCheck" checked>
                        <label class="checkbox-label" for="birdsCheck">Birds</label>
                    </div>
                    <div class="feature-item">
                        <input type="checkbox" id="sunlightCheck" checked>
                        <label class="checkbox-label" for="sunlightCheck">Sunlight</label>
                    </div>
                    <div class="feature-item">
                        <input type="checkbox" id="rainbowCheck" checked>
                        <label class="checkbox-label" for="rainbowCheck">Rainbow</label>
                    </div>
                    <div class="feature-item">
                        <input type="checkbox" id="treesCheck" checked>
                        <label class="checkbox-label" for="treesCheck">Trees</label>
                    </div>
                    <div class="feature-item">
                        <input type="checkbox" id="butterfliesCheck" checked>
                        <label class="checkbox-label" for="butterfliesCheck">Butterflies</label>
                    </div>
                    <div class="feature-item">
                        <input type="checkbox" id="fishCheck" checked>
                        <label class="checkbox-label" for="fishCheck">Fish</label>
                    </div>
                    <div class="feature-item">
                        <input type="checkbox" id="cloudsCheck" checked>
                        <label class="checkbox-label" for="cloudsCheck">Clouds</label>
                    </div>
                    <div class="feature-item">
                        <input type="checkbox" id="fireflyCheck" checked>
                        <label class="checkbox-label" for="fireflyCheck">Fireflies</label>
                    </div>
                    <div class="feature-item">
                        <input type="checkbox" id="godraysCheck" checked>
                        <label class="checkbox-label" for="godraysCheck">God Rays</label>
                    </div>
                    <div class="feature-item">
                        <input type="checkbox" id="leavesCheck" checked>
                        <label class="checkbox-label" for="leavesCheck">Leaves</label>
                    </div>
                    <div class="feature-item">
                        <input type="checkbox" id="ripplesCheck" checked>
                        <label class="checkbox-label" for="ripplesCheck">Ripples</label>
                    </div>
                </div>
            </div>
        </div>

        <canvas id="canvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Settings
        const settings = {
            time: 12,
            intensity: 0.5,
            mist: 0.7,
            speed: 1.0,
            weather: 'clear',
            rocks: true,
            birds: true,
            sunlight: true,
            rainbow: true,
            trees: true,
            butterflies: true,
            fish: true,
            clouds: true,
            fireflies: true,
            godrays: true,
            leaves: true,
            ripples: true
        };

        // Event Listeners
        document.getElementById('timeSlider').addEventListener('input', (e) => {
            settings.time = parseFloat(e.target.value);
        });

        document.getElementById('intensitySlider').addEventListener('input', (e) => {
            settings.intensity = parseFloat(e.target.value) / 100;
        });

        document.getElementById('mistSlider').addEventListener('input', (e) => {
            settings.mist = parseFloat(e.target.value) / 100;
        });

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            settings.speed = parseFloat(e.target.value);
        });

        document.getElementById('weatherSelect').addEventListener('change', (e) => {
            settings.weather = e.target.value;
        });

        document.getElementById('rocksCheck').addEventListener('change', (e) => {
            settings.rocks = e.target.checked;
        });

        document.getElementById('birdsCheck').addEventListener('change', (e) => {
            settings.birds = e.target.checked;
        });

        document.getElementById('sunlightCheck').addEventListener('change', (e) => {
            settings.sunlight = e.target.checked;
        });

        document.getElementById('rainbowCheck').addEventListener('change', (e) => {
            settings.rainbow = e.target.checked;
        });

        document.getElementById('treesCheck').addEventListener('change', (e) => {
            settings.trees = e.target.checked;
        });

        document.getElementById('butterfliesCheck').addEventListener('change', (e) => {
            settings.butterflies = e.target.checked;
        });

        document.getElementById('fishCheck').addEventListener('change', (e) => {
            settings.fish = e.target.checked;
        });

        document.getElementById('cloudsCheck').addEventListener('change', (e) => {
            settings.clouds = e.target.checked;
        });

        document.getElementById('fireflyCheck').addEventListener('change', (e) => {
            settings.fireflies = e.target.checked;
        });

        document.getElementById('godraysCheck').addEventListener('change', (e) => {
            settings.godrays = e.target.checked;
        });

        document.getElementById('leavesCheck').addEventListener('change', (e) => {
            settings.leaves = e.target.checked;
        });

        document.getElementById('ripplesCheck').addEventListener('change', (e) => {
            settings.ripples = e.target.checked;
        });

        function togglePanel() {
            const panel = document.getElementById('controlPanel');
            panel.classList.toggle('collapsed');
        }

        function updateTimeDisplay() {
            const hour = Math.floor(settings.time);
            const minutes = Math.floor((settings.time - hour) * 60);
            document.getElementById('timeDisplay').textContent = 
                `${hour.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
        }

        function updateIntensityDisplay() {
            document.getElementById('intensityDisplay').textContent = 
                `${Math.round(settings.intensity * 100)}%`;
        }

        function updateMistDisplay() {
            document.getElementById('mistDisplay').textContent = 
                `${Math.round(settings.mist * 100)}%`;
        }

        function updateSpeedDisplay() {
            document.getElementById('speedDisplay').textContent = 
                `${settings.speed.toFixed(1)}x`;
        }

        // Particle Systems
        class WaterParticle {
            constructor(x, y, vx, vy, life) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.life = life;
                this.maxLife = life;
                this.size = Math.random() * 3 + 2;
                this.gravity = 0.3;
            }

            update() {
                this.vy += this.gravity * settings.speed;
                this.x += this.vx * settings.speed;
                this.y += this.vy * settings.speed;
                this.life -= settings.speed;
            }

            draw(ctx) {
                const alpha = (this.life / this.maxLife) * 0.8;
                ctx.fillStyle = `rgba(200, 230, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class MistParticle {
            constructor(x, y, vx, vy, life) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.life = life;
                this.maxLife = life;
                this.size = Math.random() * 20 + 10;
            }

            update() {
                this.x += this.vx * settings.speed;
                this.y += this.vy * settings.speed;
                this.life -= settings.speed * 0.5;
            }

            draw(ctx) {
                const alpha = (this.life / this.maxLife) * 0.3;
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                gradient.addColorStop(0, `rgba(220, 240, 255, ${alpha})`);
                gradient.addColorStop(1, `rgba(220, 240, 255, 0)`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Bird {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height * 0.5;
                this.speed = Math.random() * 2 + 1;
                this.angle = Math.random() * Math.PI * 2;
                this.wingAngle = 0;
                this.size = Math.random() * 10 + 15;
            }

            update() {
                this.wingAngle += 0.3 * settings.speed;
                this.x += Math.cos(this.angle) * this.speed * settings.speed;
                this.y += Math.sin(this.angle) * this.speed * 0.3 * settings.speed;

                if (this.x > canvas.width + 50) this.x = -50;
                if (this.x < -50) this.x = canvas.width + 50;
                if (this.y > canvas.height * 0.5) this.y = 0;
                if (this.y < 0) this.y = canvas.height * 0.5;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                const wingFlap = Math.sin(this.wingAngle) * 10;
                
                ctx.fillStyle = 'rgba(50, 50, 50, 0.7)';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.quadraticCurveTo(-this.size, wingFlap, -this.size * 1.5, wingFlap * 0.5);
                ctx.quadraticCurveTo(-this.size, 0, 0, 0);
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.quadraticCurveTo(this.size, -wingFlap, this.size * 1.5, -wingFlap * 0.5);
                ctx.quadraticCurveTo(this.size, 0, 0, 0);
                ctx.fill();

                ctx.restore();
            }
        }

        class Butterfly {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.speed = Math.random() * 0.5 + 0.3;
                this.angle = Math.random() * Math.PI * 2;
                this.wingAngle = 0;
                this.hue = Math.random() * 360;
                this.size = Math.random() * 5 + 8;
                this.wobble = Math.random() * Math.PI * 2;
            }

            update() {
                this.wingAngle += 0.5 * settings.speed;
                this.wobble += 0.05 * settings.speed;
                
                this.angle += (Math.random() - 0.5) * 0.1;
                this.x += Math.cos(this.angle) * this.speed * settings.speed;
                this.y += Math.sin(this.angle) * this.speed * settings.speed + Math.sin(this.wobble) * 0.3;

                if (this.x > canvas.width + 50) this.x = -50;
                if (this.x < -50) this.x = canvas.width + 50;
                if (this.y > canvas.height + 50) this.y = -50;
                if (this.y < -50) this.y = canvas.height + 50;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                const wingFlap = Math.abs(Math.sin(this.wingAngle)) * 15;

                ctx.fillStyle = `hsla(${this.hue}, 70%, 60%, 0.8)`;
                
                ctx.beginPath();
                ctx.ellipse(-this.size/2, -wingFlap/2, this.size, this.size * 0.7, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.ellipse(this.size/2, wingFlap/2, this.size, this.size * 0.7, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'rgba(50, 50, 50, 0.9)';
                ctx.fillRect(-2, -this.size, 4, this.size * 2);

                ctx.restore();
            }
        }

        class Fish {
            constructor(centerX, centerY, radius) {
                this.centerX = centerX;
                this.centerY = centerY;
                this.radius = radius;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = Math.random() * 0.02 + 0.01;
                this.depth = Math.random();
                this.size = Math.random() * 15 + 10;
                this.tailAngle = 0;
                this.hue = Math.random() * 60 + 180;
            }

            update() {
                this.angle += this.speed * settings.speed;
                this.tailAngle += 0.3 * settings.speed;
            }

            draw(ctx) {
                const x = this.centerX + Math.cos(this.angle) * this.radius * 0.8;
                const y = this.centerY + Math.sin(this.angle) * this.radius * 0.3 + 30;
                
                const alpha = 0.3 + this.depth * 0.4;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(this.angle + Math.PI / 2);

                const tailWag = Math.sin(this.tailAngle) * 8;

                ctx.fillStyle = `hsla(${this.hue}, 60%, 50%, ${alpha})`;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size * 0.5, this.size, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(0, this.size);
                ctx.lineTo(-this.size * 0.4 + tailWag, this.size * 1.5);
                ctx.lineTo(this.size * 0.4 + tailWag, this.size * 1.5);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
                ctx.beginPath();
                ctx.arc(this.size * 0.2, -this.size * 0.3, 2, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        class Firefly {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = canvas.height * 0.3 + Math.random() * canvas.height * 0.5;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.brightness = Math.random();
                this.flickerSpeed = Math.random() * 0.05 + 0.03;
                this.size = Math.random() * 3 + 2;
            }

            update() {
                this.brightness += this.flickerSpeed * settings.speed;
                if (this.brightness > 1 || this.brightness < 0) {
                    this.flickerSpeed *= -1;
                }

                this.x += this.vx * settings.speed;
                this.y += this.vy * settings.speed;

                if (this.x > canvas.width) this.x = 0;
                if (this.x < 0) this.x = canvas.width;
                if (this.y > canvas.height) this.y = canvas.height * 0.3;
                if (this.y < canvas.height * 0.3) this.y = canvas.height;
            }

            draw(ctx) {
                const glow = this.brightness * 20;
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glow);
                gradient.addColorStop(0, `rgba(255, 255, 150, ${this.brightness})`);
                gradient.addColorStop(0.5, `rgba(255, 255, 100, ${this.brightness * 0.5})`);
                gradient.addColorStop(1, 'rgba(255, 255, 100, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glow, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Cloud {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height * 0.3;
                this.speed = Math.random() * 0.2 + 0.1;
                this.size = Math.random() * 80 + 60;
                this.opacity = Math.random() * 0.3 + 0.2;
            }

            update() {
                this.x += this.speed * settings.speed;
                if (this.x > canvas.width + this.size) {
                    this.x = -this.size;
                    this.y = Math.random() * canvas.height * 0.3;
                }
            }

            draw(ctx) {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 0.5, 0, Math.PI * 2);
                ctx.arc(this.x + this.size * 0.3, this.y, this.size * 0.4, 0, Math.PI * 2);
                ctx.arc(this.x - this.size * 0.3, this.y, this.size * 0.4, 0, Math.PI * 2);
                ctx.arc(this.x, this.y - this.size * 0.2, this.size * 0.35, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Leaf {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = -20;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = Math.random() * 0.5 + 0.3;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.1;
                this.size = Math.random() * 8 + 6;
                this.hue = Math.random() * 60 + 10;
                this.swayPhase = Math.random() * Math.PI * 2;
            }

            update() {
                this.swayPhase += 0.05 * settings.speed;
                this.x += (this.vx + Math.sin(this.swayPhase) * 0.5) * settings.speed;
                this.y += this.vy * settings.speed;
                this.rotation += this.rotationSpeed * settings.speed;

                if (this.y > canvas.height + 20) {
                    this.y = -20;
                    this.x = Math.random() * canvas.width;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                ctx.fillStyle = `hsla(${this.hue}, 60%, 40%, 0.7)`;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size, this.size * 1.5, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = `hsla(${this.hue}, 60%, 30%, 0.8)`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, -this.size * 1.5);
                ctx.lineTo(0, this.size * 1.5);
                ctx.stroke();

                ctx.restore();
            }
        }

        class Ripple {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 0;
                this.maxRadius = Math.random() * 100 + 80;
                this.life = 100;
                this.speed = Math.random() * 2 + 1;
            }

            update() {
                this.radius += this.speed * settings.speed;
                this.life -= settings.speed;
            }

            draw(ctx) {
                const alpha = (this.life / 100) * 0.3;
                ctx.strokeStyle = `rgba(200, 230, 255, ${alpha})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        class Splash {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.particles = [];
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2;
                    const speed = Math.random() * 3 + 2;
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 2,
                        life: 30
                    });
                }
            }

            update() {
                this.particles.forEach(p => {
                    p.vy += 0.3;
                    p.x += p.vx * settings.speed;
                    p.y += p.vy * settings.speed;
                    p.life -= settings.speed;
                });
                this.particles = this.particles.filter(p => p.life > 0);
            }

            draw(ctx) {
                this.particles.forEach(p => {
                    const alpha = (p.life / 30) * 0.6;
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            isDead() {
                return this.particles.length === 0;
            }
        }

        // Initialize particles and objects
        let waterParticles = [];
        let mistParticles = [];
        let birds = [];
        let butterflies = [];
        let fish = [];
        let fireflies = [];
        let clouds = [];
        let leaves = [];
        let ripples = [];
        let splashes = [];
        let godRays = [];

        // Initialize birds
        for (let i = 0; i < 5; i++) {
            birds.push(new Bird());
        }

        // Initialize butterflies
        for (let i = 0; i < 8; i++) {
            butterflies.push(new Butterfly());
        }

        // Initialize fireflies
        for (let i = 0; i < 20; i++) {
            fireflies.push(new Firefly());
        }

        // Initialize clouds
        for (let i = 0; i < 6; i++) {
            clouds.push(new Cloud());
        }

        // Initialize leaves
        for (let i = 0; i < 15; i++) {
            const leaf = new Leaf();
            leaf.y = Math.random() * canvas.height;
            leaves.push(leaf);
        }

        function getSkyColor() {
            const hour = settings.time;
            
            if (hour >= 5 && hour < 7) {
                const t = (hour - 5) / 2;
                return {
                    top: `rgba(${135 + t * 50}, ${206 - t * 70}, ${250 - t * 100}, 1)`,
                    middle: `rgba(${255 - t * 105}, ${180 + t * 100}, ${200 - t * 50}, 0.8)`,
                    bottom: `rgba(${255 - t * 105}, ${150 + t * 80}, ${100 + t * 50}, 0.6)`
                };
            } else if (hour >= 7 && hour < 17) {
                return {
                    top: 'rgba(135, 206, 250, 1)',
                    middle: 'rgba(150, 220, 255, 0.8)',
                    bottom: 'rgba(180, 230, 255, 0.6)'
                };
            } else if (hour >= 17 && hour < 20) {
                const t = (hour - 17) / 3;
                return {
                    top: `rgba(${135 - t * 85}, ${206 - t * 156}, ${250 - t * 180}, 1)`,
                    middle: `rgba(${255 - t * 105}, ${150 - t * 80}, ${100 - t * 50}, 0.8)`,
                    bottom: `rgba(${255 - t * 130}, ${100 - t * 60}, ${50 - t * 30}, 0.6)`
                };
            } else {
                return {
                    top: 'rgba(10, 10, 30, 1)',
                    middle: 'rgba(20, 20, 50, 0.8)',
                    bottom: 'rgba(30, 30, 60, 0.6)'
                };
            }
        }

        function getWaterColor() {
            const hour = settings.time;
            
            if (hour >= 7 && hour < 17) {
                return 'rgba(100, 180, 220, 0.8)';
            } else if (hour >= 17 && hour < 20) {
                return 'rgba(150, 120, 180, 0.7)';
            } else {
                return 'rgba(50, 80, 120, 0.6)';
            }
        }

        function drawBackground() {
            const colors = getSkyColor();
            
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, colors.top);
            gradient.addColorStop(0.5, colors.middle);
            gradient.addColorStop(1, colors.bottom);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Stars at night
            if (settings.time < 5 || settings.time > 21) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                for (let i = 0; i < 100; i++) {
                    const x = (i * 123.456) % canvas.width;
                    const y = (i * 789.012) % (canvas.height * 0.6);
                    const twinkle = Math.sin(Date.now() * 0.001 + i) * 0.5 + 0.5;
                    const size = Math.random() * 2 + 1;
                    
                    ctx.globalAlpha = twinkle * 0.8;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            }

            // Draw clouds
            if (settings.clouds) {
                clouds.forEach(cloud => {
                    cloud.update();
                    cloud.draw(ctx);
                });
            }

            // Moon at night
            if (settings.time < 5 || settings.time > 20) {
                const moonX = canvas.width * 0.8;
                const moonY = canvas.height * 0.15;
                
                ctx.fillStyle = 'rgba(240, 240, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(moonX, moonY, 40, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'rgba(200, 200, 220, 0.3)';
                ctx.beginPath();
                ctx.arc(moonX - 15, moonY - 10, 8, 0, Math.PI * 2);
                ctx.arc(moonX + 10, moonY + 5, 12, 0, Math.PI * 2);
                ctx.fill();
            }

            // Overlay for time of day
            if (settings.time < 6 || settings.time > 20) {
                ctx.fillStyle = 'rgba(10, 10, 30, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        function drawTrees() {
            if (!settings.trees) return;

            const drawTree = (x, y, scale) => {
                const sway = Math.sin(Date.now() * 0.001 + x) * 2;
                
                ctx.save();
                ctx.translate(x + sway, y);

                // Trunk
                ctx.fillStyle = 'rgba(80, 60, 40, 0.8)';
                ctx.beginPath();
                ctx.moveTo(-10 * scale, 0);
                ctx.lineTo(-8 * scale, -80 * scale);
                ctx.lineTo(8 * scale, -80 * scale);
                ctx.lineTo(10 * scale, 0);
                ctx.closePath();
                ctx.fill();

                // Foliage layers
                const foliageColors = [
                    'rgba(34, 139, 34, 0.8)',
                    'rgba(50, 160, 50, 0.7)',
                    'rgba(70, 180, 70, 0.6)'
                ];

                foliageColors.forEach((color, i) => {
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(0, -80 * scale - i * 30 * scale);
                    ctx.lineTo(-40 * scale, -50 * scale - i * 30 * scale);
                    ctx.lineTo(40 * scale, -50 * scale - i * 30 * scale);
                    ctx.closePath();
                    ctx.fill();
                });

                ctx.restore();
            };

            // Left side trees
            drawTree(100, canvas.height * 0.7, 1.2);
            drawTree(180, canvas.height * 0.75, 0.9);
            drawTree(80, canvas.height * 0.8, 0.7);
            
            // Right side trees
            drawTree(canvas.width - 100, canvas.height * 0.7, 1.1);
            drawTree(canvas.width - 200, canvas.height * 0.75, 0.95);
            drawTree(canvas.width - 150, canvas.height * 0.8, 0.75);
        }

        function drawGrass() {
            const grassColor = 'rgba(50, 150, 50, 0.6)';
            ctx.strokeStyle = grassColor;
            ctx.lineWidth = 2;

            for (let i = 0; i < 100; i++) {
                const x = (i * 17) % canvas.width;
                const y = canvas.height * 0.85 + (i * 13) % 100;
                const height = Math.random() * 20 + 10;
                const sway = Math.sin(Date.now() * 0.002 + i) * 5;

                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.quadraticCurveTo(x + sway, y - height / 2, x + sway * 2, y - height);
                ctx.stroke();
            }
        }

        function drawCliff() {
            const cliffX = canvas.width * 0.5;
            const cliffY = canvas.height * 0.3;
            const cliffWidth = 400;
            const cliffHeight = 150;

            if (settings.rocks) {
                // Main rock formation with texture
                const gradient = ctx.createLinearGradient(cliffX - cliffWidth / 2, cliffY, 
                                                        cliffX + cliffWidth / 2, cliffY + cliffHeight);
                gradient.addColorStop(0, 'rgba(120, 100, 80, 0.9)');
                gradient.addColorStop(0.5, 'rgba(100, 80, 60, 0.85)');
                gradient.addColorStop(1, 'rgba(80, 60, 40, 0.8)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(cliffX - cliffWidth / 2, cliffY + cliffHeight);
                ctx.lineTo(cliffX - cliffWidth / 2 + 50, cliffY);
                ctx.lineTo(cliffX + cliffWidth / 2 - 50, cliffY);
                ctx.lineTo(cliffX + cliffWidth / 2, cliffY + cliffHeight);
                ctx.lineTo(cliffX + 100, cliffY + cliffHeight + 50);
                ctx.lineTo(cliffX - 100, cliffY + cliffHeight + 50);
                ctx.closePath();
                ctx.fill();

                // Rock texture and details
                ctx.strokeStyle = 'rgba(60, 50, 40, 0.7)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 20; i++) {
                    const x = cliffX - cliffWidth / 2 + Math.random() * cliffWidth;
                    const y = cliffY + Math.random() * cliffHeight;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + Math.random() * 30 - 15, y + Math.random() * 20 - 10);
                    ctx.stroke();
                }

                // Moss patches
                ctx.fillStyle = 'rgba(80, 120, 60, 0.4)';
                for (let i = 0; i < 10; i++) {
                    const x = cliffX - cliffWidth / 2 + Math.random() * cliffWidth;
                    const y = cliffY + Math.random() * cliffHeight;
                    ctx.beginPath();
                    ctx.arc(x, y, Math.random() * 20 + 10, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(cliffX, cliffY + cliffHeight + 50, 120, 30, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            return { cliffX, cliffY, cliffWidth, cliffHeight };
        }

        function drawSunlight() {
            if (!settings.sunlight) return;

            const hour = settings.time;
            if (hour < 6 || hour > 20) return;

            const sunProgress = (hour - 6) / 14;
            const sunX = canvas.width * 0.2 + sunProgress * canvas.width * 0.6;
            const sunY = canvas.height * 0.1 + Math.sin(sunProgress * Math.PI) * canvas.height * 0.1;

            // Sun glow
            const glowGradient = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, 100);
            glowGradient.addColorStop(0, 'rgba(255, 255, 200, 0.8)');
            glowGradient.addColorStop(0.5, 'rgba(255, 240, 150, 0.3)');
            glowGradient.addColorStop(1, 'rgba(255, 240, 150, 0)');
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(sunX, sunY, 100, 0, Math.PI * 2);
            ctx.fill();

            // Sun rays
            ctx.save();
            ctx.translate(sunX, sunY);
            for (let i = 0; i < 12; i++) {
                ctx.rotate((Math.PI * 2) / 12);
                const rayLength = 80 + Math.sin(Date.now() * 0.001 + i) * 20;
                
                ctx.strokeStyle = 'rgba(255, 255, 200, 0.4)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(30, 0);
                ctx.lineTo(rayLength, 0);
                ctx.stroke();
            }
            ctx.restore();

            // Sun core
            ctx.fillStyle = 'rgba(255, 240, 100, 1)';
            ctx.beginPath();
            ctx.arc(sunX, sunY, 30, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawGodRays() {
            if (!settings.godrays) return;

            const hour = settings.time;
            if (hour < 7 || hour > 19) return;

            const sunProgress = (hour - 7) / 12;
            const sunX = canvas.width * 0.2 + sunProgress * canvas.width * 0.6;
            const sunY = canvas.height * 0.1;

            ctx.save();
            ctx.globalAlpha = 0.15;

            for (let i = 0; i < 8; i++) {
                const angle = -Math.PI / 3 + (i / 7) * (Math.PI / 1.5);
                const gradient = ctx.createLinearGradient(
                    sunX, sunY,
                    sunX + Math.cos(angle) * canvas.height * 2,
                    sunY + Math.sin(angle) * canvas.height * 2
                );
                
                gradient.addColorStop(0, 'rgba(255, 255, 200, 0.3)');
                gradient.addColorStop(0.5, 'rgba(255, 255, 200, 0.1)');
                gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(sunX, sunY);
                ctx.lineTo(sunX + Math.cos(angle - 0.1) * canvas.height * 2, 
                          sunY + Math.sin(angle - 0.1) * canvas.height * 2);
                ctx.lineTo(sunX + Math.cos(angle + 0.1) * canvas.height * 2, 
                          sunY + Math.sin(angle + 0.1) * canvas.height * 2);
                ctx.closePath();
                ctx.fill();
            }

            ctx.restore();
        }

        function drawWaterFall(cliffX, cliffY, cliffWidth) {
            const waterStartX = cliffX - 80;
            const waterStartY = cliffY;
            const waterEndY = canvas.height * 0.8;

            // Water flow with multiple streams
            const waterColor = getWaterColor();
            
            // Main waterfall stream
            const gradient = ctx.createLinearGradient(waterStartX, waterStartY, 
                                                     waterStartX, waterEndY);
            gradient.addColorStop(0, waterColor);
            gradient.addColorStop(0.5, 'rgba(150, 200, 230, 0.7)');
            gradient.addColorStop(1, 'rgba(120, 180, 210, 0.6)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(waterStartX - 40, waterStartY);
            ctx.quadraticCurveTo(waterStartX - 30 + Math.sin(Date.now() * 0.002) * 5, 
                               waterStartY + 100, waterStartX - 20, waterStartY + 300);
            ctx.lineTo(waterStartX + 40, waterStartY + 300);
            ctx.quadraticCurveTo(waterStartX + 30 + Math.sin(Date.now() * 0.002) * 5, 
                               waterStartY + 100, waterStartX + 40, waterStartY);
            ctx.closePath();
            ctx.fill();

            // Water highlights (animated)
            for (let i = 0; i < 3; i++) {
                const offset = (Date.now() * 0.003 + i * 0.5) % 1;
                const y = waterStartY + offset * 300;
                
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.6 * (1 - offset)})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(waterStartX - 30, y);
                ctx.quadraticCurveTo(waterStartX - 20, y + 30, waterStartX - 10, y + 60);
                ctx.stroke();
            }

            // Foam at top
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 10; i++) {
                const x = waterStartX - 40 + Math.random() * 80;
                const y = waterStartY + Math.random() * 20;
                ctx.beginPath();
                ctx.arc(x, y, Math.random() * 5 + 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Pool at bottom with reflection
            const poolGradient = ctx.createRadialGradient(cliffX, waterEndY + 50, 0, 
                                                         cliffX, waterEndY + 50, 200);
            poolGradient.addColorStop(0, 'rgba(150, 200, 230, 0.9)');
            poolGradient.addColorStop(0.5, waterColor);
            poolGradient.addColorStop(1, 'rgba(80, 140, 180, 0.7)');
            
            ctx.fillStyle = poolGradient;
            ctx.beginPath();
            ctx.ellipse(cliffX, waterEndY + 50, 200, 80, 0, 0, Math.PI * 2);
            ctx.fill();

            // Pool surface waves
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 3; i++) {
                const phase = Date.now() * 0.001 + i;
                const offset = Math.sin(phase) * 10;
                ctx.beginPath();
                ctx.ellipse(cliffX + offset, waterEndY + 50, 150 - i * 30, 50 - i * 10, 0, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Foam in pool
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2 + Date.now() * 0.0005;
                const x = cliffX + Math.cos(angle) * (150 + Math.sin(Date.now() * 0.001 + i) * 30);
                const y = waterEndY + 50 + Math.sin(angle) * 40;
                ctx.beginPath();
                ctx.arc(x, y, Math.random() * 4 + 2, 0, Math.PI * 2);
                ctx.fill();
            }

            return { waterStartX, waterStartY, waterEndY };
        }

        function drawRainbow() {
            if (!settings.rainbow) return;

            const hour = settings.time;
            if (hour < 16 || hour > 19) return;

            const centerX = canvas.width * 0.4;
            const centerY = canvas.height * 0.9;
            const colors = [
                'rgba(255, 0, 0, 0.5)',
                'rgba(255, 127, 0, 0.5)',
                'rgba(255, 255, 0, 0.5)',
                'rgba(0, 255, 0, 0.5)',
                'rgba(0, 0, 255, 0.5)',
                'rgba(75, 0, 130, 0.5)',
                'rgba(148, 0, 211, 0.5)'
            ];

            colors.forEach((color, index) => {
                const radius = 200 + index * 20;
                ctx.strokeStyle = color;
                ctx.lineWidth = 15;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, Math.PI, Math.PI * 1.6);
                ctx.stroke();
            });
        }

        function emitWaterParticles(cliffX, cliffY, waterStartX) {
            const count = Math.ceil(settings.intensity * 30);
            for (let i = 0; i < count; i++) {
                const x = waterStartX + (Math.random() - 0.5) * 80;
                const y = cliffY + Math.random() * 150;
                const vx = (Math.random() - 0.5) * 3;
                const vy = Math.random() * 3 + 2;
                waterParticles.push(new WaterParticle(x, y, vx, vy, 120));
            }
        }

        function emitMistParticles(waterStartX, waterEndY) {
            const count = Math.ceil(settings.mist * 8);
            for (let i = 0; i < count; i++) {
                const x = waterStartX + (Math.random() - 0.5) * 200;
                const y = waterEndY + Math.random() * 150;
                const vx = (Math.random() - 0.5) * 0.8;
                const vy = Math.random() * -1.5 - 0.5;
                mistParticles.push(new MistParticle(x, y, vx, vy, 200));
            }
        }

        function drawRain() {
            if (settings.weather !== 'rain' && settings.weather !== 'storm') return;

            const rainIntensity = settings.weather === 'storm' ? 150 : 80;
            
            for (let i = 0; i < rainIntensity; i++) {
                const x = Math.random() * canvas.width;
                const y = (Math.random() * canvas.height + Date.now() * 0.8) % canvas.height;
                const length = Math.random() * 15 + 10;
                
                ctx.strokeStyle = 'rgba(150, 200, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x - 5, y + length);
                ctx.stroke();
            }
        }

        function drawLightning() {
            if (settings.weather !== 'storm') return;
            
            if (Math.random() < 0.01) {
                const startX = Math.random() * canvas.width;
                const segments = 8;
                let x = startX;
                let y = 0;
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.lineWidth = 4;
                ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                ctx.shadowBlur = 20;
                
                ctx.beginPath();
                ctx.moveTo(x, y);
                
                for (let i = 0; i < segments; i++) {
                    x += (Math.random() - 0.5) * 100;
                    y += canvas.height / segments;
                    ctx.lineTo(x, y);
                }
                
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Flash effect
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        // Create initial ripples periodically
        setInterval(() => {
            if (settings.ripples && Math.random() < 0.3) {
                const x = canvas.width * 0.5 + (Math.random() - 0.5) * 300;
                const y = canvas.height * 0.8 + 50;
                ripples.push(new Ripple(x, y));
            }
        }, 1000);

        // Create splashes periodically
        setInterval(() => {
            if (Math.random() < 0.2) {
                const x = canvas.width * 0.5 - 80 + (Math.random() - 0.5) * 60;
                const y = canvas.height * 0.8;
                splashes.push(new Splash(x, y));
            }
        }, 500);

        function animate() {
            // Clear and draw background
            drawBackground();

            // Draw god rays first (behind everything)
            drawGodRays();

            // Draw trees and grass
            drawTrees();
            drawGrass();

            // Draw cliff
            const { cliffX, cliffY, cliffWidth, cliffHeight } = drawCliff();
            const { waterStartX, waterStartY, waterEndY } = drawWaterFall(cliffX, cliffY, cliffWidth);

            // Initialize fish if not done
            if (settings.fish && fish.length === 0) {
                for (let i = 0; i < 8; i++) {
                    fish.push(new Fish(cliffX, waterEndY + 50, 180));
                }
            }

            // Draw and update fish
            if (settings.fish) {
                fish.forEach(f => {
                    f.update();
                    f.draw(ctx);
                });
            } else {
                fish = [];
            }

            // Draw sunlight
            drawSunlight();

            // Emit and update particles
            emitWaterParticles(cliffX, cliffY, waterStartX);
            emitMistParticles(waterStartX, waterEndY);

            // Update and draw water particles
            waterParticles = waterParticles.filter(p => p.life > 0);
            waterParticles.forEach(p => {
                p.update();
                p.draw(ctx);
            });

            // Update and draw mist particles
            mistParticles = mistParticles.filter(p => p.life > 0);
            mistParticles.forEach(p => {
                p.update();
                p.draw(ctx);
            });

            // Update and draw ripples
            if (settings.ripples) {
                ripples = ripples.filter(r => r.life > 0);
                ripples.forEach(r => {
                    r.update();
                    r.draw(ctx);
                });
            }

            // Update and draw splashes
            splashes = splashes.filter(s => !s.isDead());
            splashes.forEach(s => {
                s.update();
                s.draw(ctx);
            });

            // Draw rainbow
            drawRainbow();

            // Draw rain and lightning
            drawRain();
            drawLightning();

            // Draw and update birds
            if (settings.birds) {
                birds.forEach(bird => {
                    bird.update();
                    bird.draw(ctx);
                });
            }

            // Draw and update butterflies
            if (settings.butterflies) {
                butterflies.forEach(butterfly => {
                    butterfly.update();
                    butterfly.draw(ctx);
                });
            }

            // Draw and update fireflies (only at night)
            if (settings.fireflies && (settings.time < 6 || settings.time > 20)) {
                fireflies.forEach(firefly => {
                    firefly.update();
                    firefly.draw(ctx);
                });
            }

            // Draw and update falling leaves
            if (settings.leaves) {
                leaves.forEach(leaf => {
                    leaf.update();
                    leaf.draw(ctx);
                });
            }

            // Update displays
            updateTimeDisplay();
            updateIntensityDisplay();
            updateMistDisplay();
            updateSpeedDisplay();

            requestAnimationFrame(animate);
        }

        // Start animation
        animate();
    </script>
</body>
</html>